
#include "PropertyItem.hpp"

#include <rtt/base/PropertyBase.hpp>
#include <rtt/types/TypeInfo.hpp>
#include <base-logging/Logging.hpp>

#include "Types.hpp"
#include "TypedItem.hpp"
#include "ConfigItem.hpp"

PropertyItem::PropertyItem(RTT::base::PropertyBase *property, ConfigItemHandlerRepository *handlerrepo) : nameItem(new TypedItem(ItemType::PROPERTYITEM)), valueItem(new TypedItem(ItemType::PROPERTYITEM)), handlerrepo(handlerrepo)
{
    nameItem->setText(QString::fromStdString(property->getName()));
    nameItem->setData(this);
    valueItem->setData(this);
    typeInfo = property->getTypeInfo()->getTypeName();
    valueItem->setText(typeInfo.c_str());
    updateProperty(property);
}

PropertyItem::~PropertyItem()
{
    reset();
    delete nameItem;
    delete valueItem;
}

void PropertyItem::reset()
{
    transport = nullptr;
    transportHandle = nullptr;
    sample = nullptr;
    type = nullptr;
}

QList<QStandardItem* > PropertyItem::getRow()
{
    return {nameItem, valueItem};
}


void PropertyItem::updateProperty(RTT::base::PropertyBase* property)
{
    RTT::types::TypeInfo const *type = property->getTypeInfo();
    transport = dynamic_cast<orogen_transports::TypelibMarshallerBase *>(type->getProtocol(orogen_transports::TYPELIB_MARSHALLER_ID));
    if (! transport)
    {
        LOG_ERROR_S << "cannot edit ports of type " << type->getTypeName() << " as no typekit generated by orogen defines it";
        return;
    }

    transportHandle = transport->createSample();
    sample = transport->getDataSource(transportHandle);
    propertyDataSource = property->getDataSource();
    transport->readDataSource(*propertyDataSource, transportHandle);

    this->type = transport->getRegistry().get(transport->getMarshallingType());
}

bool PropertyItem::updataValue()
{
    transport->refreshTypelibSample(transportHandle);

    currentData = Typelib::Value(transport->getTypelibSample(transportHandle), *(type));

    if (!item)
    {
        while (nameItem->rowCount() > 0)
        {
            nameItem->takeRow(0);
        }

        item = getEditableItem(currentData, handlerrepo, this->nameItem, this->valueItem);
        return item->update(currentData, sample, true, true);
    }

    return item->update(currentData, sample, item->getName()->isExpanded());
}

const std::string& PropertyItem::getType()
{
    return typeInfo;
}

Typelib::Value &PropertyItem::getCurrentData()
{
    return currentData;
}

Typelib::Value PropertyItem::getValueHandle()
{
    return Typelib::Value(transport->getTypelibSample(transportHandle), *(type));
}

RTT::base::DataSourceBase::shared_ptr PropertyItem::getBaseSample()
{
    return sample;
}

void PropertyItem::setCurrentData()
{
   transport->writeDataSource(*propertyDataSource, transportHandle);
}
